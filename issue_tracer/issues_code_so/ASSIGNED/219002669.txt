wiredWith
variant.artifacts.get(SingleArtifact.APK))
finalizes
            project.tasks.withType(JacocoReportTask::<span class="stx-keyword">class</span>.java) {
                enabled = <span class="stx-keyword">false</span>
            }

shouldRunAfter
    <span class="stx-keyword">private</span> <span class="stx-keyword">fun</span> bumpFlankTask(<span>project</span>: <span>Project</span>, <span>flankTasks</span>: <span>TaskCollection</span>&lt;<span>FlankExecutionTask</span>&gt;) {
        listOf(AndroidLintTask::<span class="stx-keyword">class</span>.java, AndroidLintAnalysisTask::<span class="stx-keyword">class</span>.java, AndroidUnitTest::<span class="stx-keyword">class</span>.java)
            .forEach {
                project.tasks.withType(it).configureEach {
                    shouldRunAfter(flankTasks)
                }
            }
    }

BundleToStandaloneApkTask
        <span class="stx-comment">/*</span>
<span class="stx-comment">         * -Djacoco-agent.destfile arg is used to configure the offline mode behavior of jacoco.  The offline</span>
<span class="stx-comment">         * behavior is what is used when dependency module code is executed as it has already been</span>
<span class="stx-comment">         * instrumented by the jacoco-agent in previous executions.  We redirect this to record the offline</span>
<span class="stx-comment">         * results under the build directory and give it a more explicit/identifiable name (it defaults</span>
<span class="stx-comment">         * to the project dir as jacoco.exec).</span>
<span class="stx-comment">         *</span>
<span class="stx-comment">         * NOTE: Attempts at using JacocoTaskExtension.setDestinationFile were unsuccessful in capturing coverage</span>
<span class="stx-comment">         */</span>
        project.tasks.withType(AndroidUnitTest::<span class="stx-keyword">class</span>.java).configureEach {
            <span class="stx-keyword">val</span> execFile = project.layout.buildDirectory.file(<span class="stx-string">"</span><span class="stx-string">jacoco/offlineDependencies.exec</span><span class="stx-string">"</span>).get()
            jvmArgs(<span class="stx-string">"</span><span class="stx-string">-Dfile.encoding=UTF-8</span><span class="stx-string">"</span>, <span class="stx-string">"</span><span class="stx-string">-Djacoco-agent.destfile=</span>${execFile<span class="stx-keyword">}</span><span class="stx-string">"</span>)

            <span class="stx-comment">// Register our file as a task output to ensure it is restored via the build cache when execution is avoided</span>
            outputs.file(execFile)

            doFirst {
                <span class="stx-comment">// Make sure the coverage file is removed if it exists from a previous run</span>
                execFile.asFile.deleteRecursively()
            }
        }

onVariants
        project.plugins.withId(<span class="stx-string">"</span><span class="stx-string">com.android.application</span><span class="stx-string">"</span>) { plugin -&gt;
            <span class="stx-keyword">val</span> extension = project.extensions.getByType(ApplicationAndroidComponentsExtension::<span class="stx-keyword">class</span>.java)
            <span class="stx-keyword">val</span> android = project.extensions.getByType(ApplicationExtension::<span class="stx-keyword">class</span>.java)
            extension.onVariants { variant -&gt;
                ...
                <span class="stx-keyword">if</span> (android.buildTypes.getByName(variant.buildType!!).isMinifyEnabled) {
                    ...
                }

ApplicationExtension
variant.artifacts.get(SingleArtifact.APK).getTaskProvider().configure {
    it.dependsOn(<span class="stx-string">"</span><span class="stx-string">detekt</span>${variant.name.capitalize()<span class="stx-keyword">}</span><span class="stx-string">"</span>)
}

project.extensions.getByType(AndroidComponentsExtension::<span class="stx-keyword">class</span>.java).onVariants { variant -&gt;
    project.afterEvaluate {
        project.tasks.named(<span class="stx-string">"</span><span class="stx-string">assemble</span>${variant.name.capitalize()<span class="stx-keyword">}</span><span class="stx-string">"</span>).configure {
            it.dependsOn(<span class="stx-string">"</span><span class="stx-string">detekt</span>${variant.name.capitalize()<span class="stx-keyword">}</span><span class="stx-string">"</span>)
        }
    }
}

source = variant.getJavaCompileProvider().get().source
classpath += project.files(project.provider { androidExtension.bootClasspath })
classpath += project.files(variant.getJavaCompileProvider().map { it.classpath })

*.so
*.so
variant.artifacts.use(task)
    .wiredWith { it.outputSoFolder }
    .toAppendTo(...) <span class="stx-comment">// &lt;-- what to put here?</span>

AndroidArtifacts.ArtifactType
.so
SingleArtifact.*
AndroidSourceSet
AndroidSourceSet
javaCompileProvider
javaCompileProvider
android.applicationVariants.configureEach { variant -&gt;
  <span class="stx-keyword">val</span> customTaskOne = project.tasks.register(<span class="stx-string">"</span><span class="stx-string">customTaskOne</span>${variant.name.capitalized()<span class="stx-string">"</span><span class="stx-string">) {</span>
    dependsOn(variant.javaCompileProvider, kotlinCompileTask)
  <span class="stx-keyword">}</span>

  <span class="stx-keyword">val</span> javaCompileOutput = variant.javaCompileProvider.get().destinationDirectory.get().asFile
  <span class="stx-keyword">val</span> codeGenerationAction = CodeGenAction(javaCompileOutput, variant)

  variant.javaCompileProvider.configure {
    finalizedBy(customTaskOne)
    doLast(codeGenerationAction)
  }
}

preBuildProvider
.class
                variant.artifacts
                    .forScope(ScopedArtifacts.Scope.ALL)
                    .use(scannerTask)
                    .toAppend(
                        ScopedArtifact.CLASSES,
                        ScannerTask::output
                    )

                variant.artifacts.forScope(ScopedArtifacts.Scope.ALL)
                    .use(scannerTask)
                    .toGet(ScopedArtifact.CLASSES,
                        ScannerTask::allJars,
                        ScannerTask::allDirectories)


--debug
toTransform
variant.artifacts.forScope(ScopedArtifacts.Scope.ALL)
            .use(scannerTask)
            .toTransform(
                ScopedArtifact.CLASSES,
                ScannerTask::allJars,
                ScannerTask::allDirectories,
                ScannerTask::output
            )


dex
toTransform
toTransform
toTransform
finalizedBy
finalize
variant.artifacts
       .forScope(ScopedArtifacts.Scope.ALL)
       .scan(scannerTask)
       .andOutput(writeTask)
       .with(
           ScopedArtifact.CLASSES,
           ScannerTask::allJars,
           ScannerTask::allDirectories,
           WriteTask::output
        )
<span>    </span>

scannerTask
scan
